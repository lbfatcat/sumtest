
--------------------
2020.01.03 20:00
Initiation:
* the result diplay is too naive, the correct rate display is awful with a simple float number diplay;

Design Key Points:
* introduce an extra abstraction by designing the function: getResult;
* in very loop, the main module provide getResult with round count, current excercise result (right/wrong), the whole result computing chores are left to getResult, which return a retult string for the main module to diplay.
* interface design: int getResult(int iFull,char *pResult);
* int iFullFlag: flag indicating whether or not a full and detailed report is required;
* char *pResult: the result string, which need to be first reset with restBuffer function to clean the previously stored characters; 

Details:
* the round count need referenced by both the main and getResult modules, therefore the round count number can be set as a static int with the sumtest module to save the need to transfer it through inner functions within sumtest module.   ---> so the   static int glbRoundCount;
* the COMPACT result shown at the end of each loop can be of the following form:
    "   ---------------------------------------
        COUNT:20    CORRECT:10  RATIO:50.00 %
    "   ---------------------------------------
* the FULL result can be of the following form:
    "   ---------------------------------------
        TYPE        COUNT   CORRECT     RATIO
        ----------------------------------------
        ()+op1=op2  10      8           80.00%
        op1+()=op2  10      10          100.00%
        op1+op2=()  20      5           25.00%
        ----------------------------------------
        SUM         40      23          57.50%

Technical Difficulties:
* how to convert float point numbers to percentage representational strings;
* how to do tablet fashion display;
        
 --------------------
2020.01.03 19:00
Initiation:
* the current program only do simple addtition excercises with a single loop;
* lack excercise varation, such as: ()+2=10, 2+()=4, or 2+4=();
* I want to introduce excercise types, such that different types of excercises can appear in randomized fashion;

Design Key Points:
* introduce an extra abstraction by designing the function: generateExercise;
* in every loop, the main module invoke the generateExcercise function call to abtain a exercise string as well as the answer number;
* after receiving the user's input number, the main module compare the input number with the answer number returned by the generateExcercise function call; 
* Excercise Types:
    -> typeID:1, ()+op1= op2; but op1<=op2, with op1 and op2 both fall between [LOW_BOUND,UP_BOUND] 
    -> typeID:2, op1+()= op2; but op1<=op2, with op1 and op2 both fall between [LOW_BOUND,UP_BOUND] 
    -> typeID:3, op1+op2=(); with op1 and op2 both fall between [LOW_BOUND,UP_BOUND] 
* Interface Design:
    -> int generateExcercise(char * pExString);
    -> return value: the answer number of the returned excercise; -1, if anything goes wrong;

Details:
* main module is modified to get rid of the specifics of different types of excercises;
* introduce the MAX_BUF macro to correspond to the static string holding the excercise;
* in generateExcercise function, first randomly generate a type, then use a switch statement to generate specific excercise;
